#!/usr/bin/env perl
use strict;
use warnings;

use lib $ENV{GUS_HOME} . "/lib/perl";

use feature qq/switch/; # given/when
use Cwd qw/abs_path/;
use Config::Std; # read_config()
use Data::Dumper;
use File::Basename;
use File::Copy;
use Scalar::Util qw/looks_like_number/;
use JSON qw/to_json/;
use ApiCommonData::Load::OwlReader;
use ClinEpiData::Load::Utilities::File qw/csv2array tabWriter getPrefixedHeaders getValidValues/;
use XML::Simple;
use Config::Std; # read_config()

my $this = basename $0;
my ($cmd, @args) = @ARGV;

my $config = {};
my $CFGFILE = '.buildconfig';
my $CFGDIR = 'conf';

my $msg = {
  nobuild => 'Not in build dir',
  noworkspace => 'Not in a workspace',
  info => 'INFO: ',
};

my $systemcommands = {
  owl => 'grep ontologyOwlFile conf/*/prop.conf|cut -d= -f2|cut -d: -f2|uniq',
};

my @usages = (
  [ 'Usage',
    "$this [command] [parameter] ([optional parameter])",
    "",
  ],
  [
    "ordinals [valueMap.txt] ([output-file])",
    "Extract ordinals from specified valueMap.txt, prints output to terminal or [output-file]",
  ],
  [
 "owl",
 "Scans conf/*/prop.conf for owl file setting",
  ],
  [
 "ontomap ([output-file])",
 "Generates ontologyMapping.xml (default)",
  ],
  [
 "derive [category] [pattern] ([suffix])",
 "Create derived variables for [category] variables matching [pattern] by applying [category] as a suffix (or [suffix])",
  ],
);
my %usage = map { $_->[0] => $_->[1] } @usages;
## more
$usage{'clean'} = "remake .buildconfig";
$usage{'var2iri [iri]'} = "lookup the IRI for a variable/pattern";
$usage{'excol [cat]'} = "make a column exclude file for [cat]";
$usage{'check'} = "scan for missing and duplicated variables in merged files";
$usage{'run [cat]'} = "make the [cat] merged file";
$usage{'update [cat]'} = "update the [cat] merged file summaries (.tree.txt, .tree.json, .summary.txt)";
$usage{'stata13'} = "args: input [output] : extract from a Stata .dta file (or all files in a directory) to output/*.txt";
$usage{'mdfiles'} = "list metadata files";

#-----------------------------------
#-------------- RUN ----------------

my ($command, @params) = @ARGV;

init($command);
if($command){
  run($command, @params);
}
else{
  foreach my $command ( sort keys %usage ){
    printf("\n  %s\n    %s\n", $command, $usage{$command})
  }
}



#-----------------------------------
#-----------------------------------

sub run {
  my ($cmd, @args) = @_;

  for($cmd){
    when('clean'){
      unlink($CFGFILE) if(-e $CFGFILE);
      init();
    }
    when('ordinals') {
      ordinals(@args);
    }
    when('owl') {
      err($config->{global}->{owl});
    }
    when('attrs') {
      owlAttributes(@args);
    }
    when('ontomap'){
      my ($ontofile) = @args;
      if(-e 'conf/ontologyMapping.xml'){
        $ontofile ||= 'ontologyMapping.xml';
        printsystemcall('addFunctionToOntologyMapping.pl -d -S -o conf/ontologyMapping.xml > conf/func');
        printsystemcall("makeOntologyMappingFile.pl -o $config->{global}->{owl} -f conf/func > $ontofile");
        printsystemcall("ls -l $ontofile\n");
      }
    }
    when('derive'){
      derive(@args);
    }
    when('var2iri'){
      my ($cat, $var) = @args;
      my $results = var2iri($cat, $var, 1);
     #foreach my $iri (sort keys %$results){
     #  if($results->{$iri} ne '1'){ printf("%s\t%s\n", $iri, $results->{$iri}) }
     #  else{ printf("%s\n", $iri) }
     #}
    }
    when('excol'){
      my ($cat, @flags) = @args;
      if( -f $config->{$cat}->{propfile} && $config->{$cat}->{colExcludeFile}){
        my $bak;
        if( -f $config->{$cat}->{colExcludeFile}){
          $bak = $config->{$cat}->{colExcludeFile} . ".bak";
          copy($config->{$cat}->{colExcludeFile},$bak);
          err("created backup $bak");
        }
        printsystemcall( sprintf("makeExcludeCols.pl -p %s %s > %s",
          $config->{$cat}->{propfile}, join(" ", @flags), $config->{$cat}->{colExcludeFile}));
        if($bak){
          printsystemcall("diff -q $config->{$cat}->{colExcludeFile}*");
        }
      }
      else { err("Problem: propfile missing for $cat, or colExcludeFile setting not found") }
    }
    when('check'){
      check(@args);
    }
    when('run'){
      my $cat = shift @args;
      my $propfile = $config->{$cat}->{propfile};
      if(-T $propfile){
        my $overrides = "";
        if(@args){ $overrides = join(" ", @args) }
        printsystemcall("preprocessMetadata.pl -p $propfile $overrides");
      }
    }
    when('update'){
      my $cat = shift @args;
      my $propfile = $config->{$cat}->{propfile};
      if(-T $propfile){
        my $overrides = "";
        if(@args){ $overrides = join(" ", @args) }
        printsystemcall("preprocessMetadata.pl -m -p $propfile $overrides");
      }
    }
    when('whereis'){
      printsystemcall("grep '$args[0]' out/*.tree.txt",)
    }
    when('stata13'){
      stata13(@args);
    }
    when('mdfiles'){
      while( my ($cat,$prop) = each %$config ){
        next unless $prop->{metadataFile};
        my $mdfiles = mdfiles($cat);
        printf("%s:\n%s\n", $prop->{category} || $cat, join("\n",@$mdfiles));
      }
    }
    default {
      err("Command '$cmd' not implemented")
    }
  }
}

sub init {
  my ($cmd) = @_;
  $cmd ||= "_NULL_";
  $config = {};
  my $path = abs_path();
  my $build = basename($path); 
  if($build ne 'build' && $cmd ne 'init' ){ err('nobuild', $path); return  }
  my $workspace = basename(dirname($path)); 
  if($workspace ne 'workspace' && $cmd ne 'init' ){ err('noworkspace',$path); return  }
  unless( -e $CFGFILE){
    err('noconfig',"Initializing $CFGFILE");
    my $owl = systemcall($systemcommands->{owl});
    my $owlpath = sprintf("%s/ontology/release/production/%s.owl", $ENV{GUS_HOME}, $owl->[0]);
    if(@$owl > 1){ err('info','Problem: multiple owl files found in config files; using the first one found:' . join("\n",@$owl)) }
    $config->{global}->{owl} = $owl->[0];
    $config->{global}->{owlpath} = $owlpath;
    $config->{global}->{cfgdir} = $CFGDIR;
    if(-d $CFGDIR){
      opendir(DH, $CFGDIR);
      my @configdirs = grep { !/^\./ } readdir(DH);
      closedir(DH);
      foreach my $dir (@configdirs){
        my $propfile = "$CFGDIR/$dir/prop.conf";
        next unless( -f $propfile );
        read_config($propfile, my %subcfg);
        $config->{ $dir } = $subcfg{''};
        $config->{ $dir }->{ propfile } = $propfile;
      }
    }
    if( -f "conf/ontologyMapping.xml"){
   #  my $xml = XMLin( "conf/ontologyMapping.xml", forceArray => 1 );
      $config->{global}->{ontologyMappingXmlFile} = "conf/ontologyMapping.xml";
    }
    write_config($config, $CFGFILE);
  }
  read_config($CFGFILE, %$config);
}

sub owlAttributes {
  my ($outfile) = @_;
  $outfile //= "owlAttributes.txt";
  err('info', "Writing $outfile");
  my $owlname = $config->{global}->{owl};
  my $lines = systemcall("getEntityAttributesFromOwl.pl $owlname");
  if(ref($lines) eq 'ARRAY'){
    my $out = *STDOUT;
    if($outfile){ open($out, ">$outfile") or die "Cannot write $outfile: $!\n" }
    printf $out ("%s\n", $_) for @$lines;
    if($outfile){ close($out) }
  }
  else {
    err("No output, something went wrong")
  }
}


sub ordinals {
  my ($infile, $outfile) = @_;
  my %valid;
  while( my ($cat,$prop) = each %$config ){
    if( $prop->{outputFile} && -e $prop->{outputFile}){
      err("Reading values from $prop->{outputFile} ...");
      my $values = getValidValues($prop->{outputFile}, "\t");
      %valid = (%valid, %$values);
    }
  }
  my $valueMap = csv2array($infile, "\t");
  my $irimap = getIRImap();
  my %ordinals;
  my $_line = 0;
  my %errors; # per IRI
  my %warnings; # per IRI
  foreach my $row( @$valueMap ){
    $_line++;
    my ($var, $iri, $orig, $val, $order) = @$row;
    next unless (defined($iri) && defined($val) && defined($order) && $order ne "");
    my $mappedIRI = $irimap->{$iri};
    unless($mappedIRI){
      printf STDERR ("ERROR: LINE $_line: no valid IRI mapped in owl for [$iri]\n");
      next;
    }
    $iri = $mappedIRI;
    
    my $score = 0;
    unless(looks_like_number($order)){
      printf STDERR ("ERROR: LINE $_line: '$order' is not a number\n");
      $score++;
    }
    # warn if already inserted with a different ordering
    if(defined($ordinals{$iri}->{ $val }) && $ordinals{$iri}->{ $val } != $order){
      printf STDERR ("ERROR: LINE $_line: $iri $val ordinal value '%s' does not match previous: %s\n", $order, $ordinals{$iri}->{$val});
      $score++;
    }
    if ( looks_like_number($val) ){
      printf STDERR ("WARNING: LINE $_line: $iri $val looks like a number, this variable will be loaded as ORDINAL\n");
      # no decrement of $score
    }
    if ( $val =~ /UNDEF/i ){
      printf STDERR ("ERROR: LINE $_line: $iri $val cannot have an ordinal ($order)\n");
      $score++;
    }
    unless($valid{lc($var)}->{lc($orig)} || $valid{lc($iri)}->{lc($orig) || $valid{lc($val)} } ){
      printf STDERR ("WARNING: LINE $_line: $iri $var raw value is invalid '$orig', cannot map to '$val'\n");
      $score++;
    }
      
    if($score < 1){
      $ordinals{$iri}->{$val} = $order;
    }
    else{
      printf STDERR ("ERROR: LINE $_line: $iri $val FAILED $score VALIDATION TESTS\n");
    }
  }
    
    if(0 < keys %ordinals){
      my $out = *STDOUT;
      if($outfile){ open($out, ">$outfile") or die "Cannot write $outfile: $!\n" }
      printf $out ("%s\n", join("\t", qw/SOURCE_ID ordinal_values/));
      foreach my $iri (sort keys %ordinals){
        my @perm =  sort { $ordinals{$iri}->{$a} <=> $ordinals{$iri}->{$b} } keys %{$ordinals{$iri}};
        next unless @perm;
        my $json = to_json(\@perm);
        printf $out ("%s\t%s\n", $iri, $json);
      }
      if($outfile){ close($out) }
    }
  }

sub getIRImap {
  if( $config->{_irimap} ){ return $config->{_irimap} }
  my $owl = getOwl();
	my $it = $owl->execute('column2iri');
	while (my $row = $it->next) {
		my $col = $row->{col} ? $row->{col}->as_hash()->{literal} : "";
		my $sid = $row->{sid} ? $row->{sid}->as_hash()->{literal} : "";
    $col =~ s/"//g;
    $sid =~ s/"//g;
    $config->{_irimap}->{$col} = $sid;
    $config->{_irimap}->{$sid} = $sid; # also a valid key
	}
  return $config->{_irimap};
}

sub derive {
  my ($cat, $var, $suffix) = @_;
  $suffix //= $cat;
  my $headers = allPrefixedHeaders($cat);
  my @matches = grep { /$var/ } @$headers;
  my @addrows;
  foreach my $match ( @matches ){
    my $derived = join(":", $match, $suffix);
    if($suffix eq 'IRI'){
      my $lookup = var2iri($cat, "^$match\$");
      ($derived) = keys %$lookup;
    }
    push(@addrows, join("\t", $match, lc($derived)));
  }
  
  my $ancfile = $config->{ $cat }->{ ancillaryInputFile };
  if(-f $ancfile){
    err("Scanning $ancfile for $var...");
    printsystemcall("grep '$var' $ancfile");
    err("Done.");
  }
  err("Rules to add:");
  printf("%s\n", join("\n", @addrows));
  my $ans = ask("Continue y/n ?", [ 'y', 'n' ], 'y');
  if($ans eq 'y'){
    open(FH, ">>$ancfile");
    printf FH ("%s\n", join("\n", @addrows));
    close(FH);
    err("Done writing rules to $ancfile");
    my $propfile = $config->{ $cat }->{ propfile };
    printsystemcall("sed -i 's/applyMappedIRI\\s*=\\s*0/applyMappedIRI = 1/' $propfile");
  }
  else { err("No rules added.") }
  my $colexfile = $config->{ $cat }->{colExcludeFile};
  if(-f $colexfile){
    err("Scanning $colexfile for $var...");
    printsystemcall("grep '$var' $colexfile");
    err("Done.");
  }
  $ans = ask("Exclude these? \n\t" . join("\n\t", @matches) . "\n\t [y/n] ?", [ 'y', 'n' ], 'y');
  if($ans eq 'y'){
    open(FH, ">>$colexfile");
    printf FH ("%s\n", join("\n", @matches));
    close(FH);
    err("Done adding columns to $colexfile.");
  }
  else { err("Original columns will not be excluded.") }
}

sub var2iri {
  my ($cat, $var, $verbose) = @_;
  my $category;
  if(!$var){
    $var = $cat; #shift vars
  }
  elsif($config->{$cat}){
    $category = $config->{$cat}->{parentCategory} || $config->{$cat}->{category};
  }
  my $xml = XMLin( $config->{global}->{ontologyMappingXmlFile}, forceArray => 1 );
  my %results;
  foreach my $ot ( @{ $xml->{ontologyTerm} } ){
    foreach my $name ( @{ $ot->{name} } ){
      next unless( $name =~ /$var/ );
      next if($category && $ot->{category} && lc($ot->{category}) ne $category);
      $results{$ot->{source_id}} = $ot->{category} || 1;
      if($verbose){
        printf STDERR ("%s\n", join("\t", $ot->{source_id}, $ot->{category} ||"-", $name));
      }
    }
  }
  return \%results;
}

sub allPrefixedHeaders {
  my ($cat) = @_;
  my $files = mdfiles($cat);
  my @headers;
  foreach my $file (@$files){
    my $h = getPrefixedHeaders($file, "\t");
    push(@headers, @$h);
  }
  return \@headers;
}

sub fileprefix {
  my ($file) = @_;
  return lc(basename($file, /\.[^.]*$/))
}

sub mdfiles {
  my($cat) = @_;
  my $md = [];
  my @files;
  my $mdconf = $config->{$cat}->{metadataFile};
  return unless $mdconf;
  if( ref($mdconf) eq 'ARRAY' ){ $md = $mdconf }
  else{ push(@$md, $mdconf) }
  foreach my $x ( @$md ){
    if( -d $x ){
      opendir(DH, $config->{$cat}->{metadataFile});
      foreach my $file ( grep { !/^\./ } readdir(DH) ){
        if( -f "$x/$file" ){ push( @files, "$x/$file" ) }
      }
    }
    elsif ( -f $x ){ push( @files, $x ) }
  }
  return \@files;
}

sub stata13 {
  my ($in,$out) = @_;
  my @infiles;
  if(-d $in){
    opendir(DH,$in) or die "Cannot read $in: $!\n";
    @infiles = map { "$in/$_" } grep { !/^\./ } readdir(DH);
    closedir(DH);
  }
  else {
    @infiles = ($in);
  }
  $out //= "./";
  unless( -d $out ){ err("Not a valid output directory: $out"); return }
  foreach my $infile ( @infiles ){
     unless($infile && -f $infile){ err("$infile is not a file"); next }
     my $basename = fileparse($infile, qw/\.[^.]*$/);
     my $outfile = "$out/$basename.txt";
     if( -e $infile ){
       if( -e $outfile ){
         my $r = ask("$outfile exits! Overwrite [y/n] ?",[qw/y n/],'y');
         return unless $r eq 'y';
       }
     }
     else {
       err("$infile not found");
       return;
     }
     my $call = "stata2txt '$infile' '$outfile' 1";
     err($call);
     printsystemcall($call);
     if( -e $outfile){
       err("Done");
       printsystemcall("ls -l '$outfile'");
     }
     else {
       err("Something went wrong, '$outfile' was not created");
     }
  }
}

sub getOwl {
  err('info', "owl file = " . $config->{global}->{owlpath});
  unless( $config->{_owlpath} ){ $config->{_owl} = ApiCommonData::Load::OwlReader->new($config->{global}->{owlpath}) }
  return $config->{_owl} 
}

sub ask {
  my ($msg,$opts,$default) = @_;
  my $options = "";
  if(ref($opts) eq 'ARRAY') { $options = sprintf("(%s)", join(" ", @$opts))}
  printf STDERR ("%s %s ? %s", $msg, $options, $default ? "default: $default " : "");
	while(my $r = <STDIN>){
		chomp $r;
    if( $r eq "" && $default){
      return $default
    }
    if( my ($response) =  grep { /^$r$/ } @$opts ) {
      return $response;
    }
		else {
			print "$r is not a valid option\n";
      printf STDERR ("%s (%s) ? %s", $msg, $options, $default ? "default: $default " : "");
		}
	}
}

sub check {
  my ($dir) = @_;
  my @files;
  if($dir && -d $dir){
    opendir(DH, $dir);
    my @files = map { "$dir/$_" } grep { !/^\./ && !/\.txt\./ && /\.txt/ } readdir(DH);
  }
  else {
    while(my ($cat, $prop) = each %$config){
      if($prop->{outputFile} && -e $prop->{outputFile}){
        push(@files,  $prop->{outputFile})
      }
    }
  }
  if(@files){
    unshift(@files, $config->{global}->{ontologyMappingXmlFile});
    printsystemcall(join(" ", "checkMergedFiles.pl", @files));
  }
  else { err("No output files found") }
}
    

sub systemcall {
  my $call = join(" ", @_);
  #err('info', "Execute: $call");
  open(COM, "$call |") or die "Cannot run system call '$call'\nError:$!\n";
  my @result;
  while(<COM>){
    chomp;
    s/^\s+//;
    s/\s+$//;
    push(@result, $_);
  }
  return \@result;
}

sub printsystemcall {
  my $result = systemcall(@_);
  printf ("%s\n", join("\n", @$result));
}

sub err {
  my ($key,@other) = @_;
  printf STDERR ("%s\n", $msg->{$key} || $key);
  if(@other){
    printf STDERR ("%s\n", join("\n", @other));
  }
}
